# Data Structures and Algorithms

# Big O
- Computer programs are collection of data and functions
- Multiple implementations of a single problem exist, multiple developers coming up with different solution, who is best. Example of string reverse on stack overflow
- Idea of good code vs bad code
- Most important is scalable code
- Why it matters as my solution works - your solution might work for handful of data but what about millions of data. Examples - amazon products, twitter tweets, Instagram feeds etc. Itâ€™s important in terms of interviews.
- Ways of justifying a code - Excellent, Good, Fair, Bad, Horrible
- Practical example: Write a function that calculates sum of all the numbers starting from 1 upto N.
- How can we say which solution is better? - Readable, fast, memory efficient.
- Lets say performance matters a lot - use performance.now() js function, results are machine specific, hence we can take them as judgement calls only

# Big O Expressions
- We can come up with a big o expression of solution by counting number of operations
- Big O can 5n + 2 but we look for general trends - O(n)
- Bio O allows us to identify the runtime of an algorithm as input grows it impacts the runtime of an algo as well
- Three major Big O expressions:
- f(n) = n linear, O(n)
- f(n) = n^2 quadratic, O(n^2)
- f(n) = 1 constant, O(1)

# Time complexity & Space complexity

# How to solve coding problems?
- You get a problem to solve in an interview
- Problem solving can be learned, don't feel bad if you got low IQ
- Problems can be solved with existing patterns
- PRACTICE! PRACTICE! PRACTICE! PRACTICE! PRACTICE!
- Step 1: Understand The Problem
- Restate the problem statement in your own words
- What are the inputs?
- What are the output?
- Error handling
- Time vs space complexity
- Step 2: Breaking The Problem Into Simple Steps
- Write down the approach in plain english
- Write down the brute force approach until you have the efficient solution
- Discuss the solution with an interviewer
- Step 3: Solve The Problem
- Write down the actual solution
- Write down the simple solution first
- Step 4: Re-iterate And Refactor
- Look back and see the scope of improvement in terms of performance, results, code refactoring etc.
- Check for code quality, readability, best practices etc.

